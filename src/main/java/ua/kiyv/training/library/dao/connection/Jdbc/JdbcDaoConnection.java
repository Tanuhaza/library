package ua.kiyv.training.library.dao.connection.Jdbc;




import org.apache.log4j.Logger;
import ua.kiyv.training.library.dao.DaoException;
import ua.kiyv.training.library.dao.connection.DaoConnection;
import ua.kiyv.training.library.utils.constants.LoggerMessages;
import ua.kiyv.training.library.utils.constants.MessageKeys;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;


public class JdbcDaoConnection implements DaoConnection {

    private static final Logger logger = Logger.getLogger(JdbcDaoConnection.class);

    private Connection connection;
    private boolean isInTransaction;

    JdbcDaoConnection(Connection connection) {
        this.connection = connection;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) {
        try {
            return connection.prepareStatement(sql, autoGeneratedKeys);
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_PREPARE_STATEMENT_WITH_AUTO_GENERATED_KEYS);
            throw new DaoException(ex, MessageKeys.PREPARE_STATEMENT_PROBLEM_WITH_AUTO_GENERATED_KEYS);
        }
    }

    @Override
    public PreparedStatement prepareStatement(String sql) {
        try {
            return connection.prepareStatement(sql);
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_PREPARE_STATEMENT);
            throw new DaoException(ex,MessageKeys.CAN_NOT_PREPARE_STATEMENT);
        }
    }

    @Override
    public Statement createStatement() {
        try {
            return connection.createStatement();
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_CREATE_STATEMENT);
            throw new DaoException(ex, MessageKeys.CAN_NOT_CREATE_CREATE_STATEMENT);
        }
    }

    @Override
    public void setIsInTransaction(boolean isInTransaction) {
        this.isInTransaction = isInTransaction;
        try {
            connection.setAutoCommit(!isInTransaction);
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_SET_IN_TRANSACTION);
            throw new DaoException(ex,MessageKeys.TRANSACTION_CAN_NOT_SET);
        }
    }

    @Override
    public void commit() {
        if (!isInTransaction) {
            throw new DaoException(MessageKeys.CAN_NOT_COMMIT_IS_IN_TRANSACTION);
        }
        try {
            connection.commit();
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_COMMIT);
            throw new DaoException(ex,MessageKeys.TRANSACTION_CAN_NOT_COMMIT);
        }
    }

    @Override
    public void rollback() {
        if (!isInTransaction) {
            throw new DaoException(MessageKeys.CAN_NOT_ROLLBACK_IS_IN_TRANSACTION);
        }
        try {
            connection.rollback();
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_ROLLBACK);
            throw new DaoException(ex,MessageKeys.TANSACTION_CAN_NOT_ROLLBACK);
        }
    }

    @Override
    public void close() {
        try {
            if (!isInTransaction) {
                connection.close();
            }
        } catch (SQLException ex) {
            logger.error(LoggerMessages.CAN_NOT_CLOSE_CONNECTION);
            throw new DaoException(ex,MessageKeys.CAN_NOT_CLOSE_CONNECTION);
        }
    }
}